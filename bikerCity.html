<!DOCTYPE html>
<html>
<head>
    <title>Infinite Industrial City</title>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        camera.position.set(0, 5, 0);
        camera.rotation.y = Math.PI;

        const BASE_CHUNK_SIZE = 64;
        const VIEW_DISTANCE = 3;
        const chunks = {};
        const noise = new SimplexNoise();

        function getChunkKey(x, z) {
            return `${Math.floor(x / BASE_CHUNK_SIZE)},${Math.floor(z / BASE_CHUNK_SIZE)}`;
        }

        function generateChunk(chunkX, chunkZ) {
            const chunkGroup = new THREE.Group();
            const chunkSize = BASE_CHUNK_SIZE + noise.noise2D(chunkX * 0.05, chunkZ * 0.05) * 32;
            const blockSize = 12;
            const roadWidth = 4;
            const gridSize = Math.floor((chunkSize - roadWidth) / (blockSize + roadWidth));

            const offsetX = noise.noise2D(chunkX * 0.1, chunkZ * 0.1) * blockSize * 2;
            const offsetZ = noise.noise2D(chunkX * 0.1 + 100, chunkZ * 0.1 + 100) * blockSize * 2;
            const rotation = noise.noise2D(chunkX * 0.1 + 200, chunkZ * 0.1 + 200) * 0.3;

            const groundGeo = new THREE.PlaneGeometry(chunkSize, chunkSize);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            chunkGroup.add(ground);

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = i * (blockSize + roadWidth) - (chunkSize / 2) + roadWidth / 2 + offsetX;
                    const z = j * (blockSize + roadWidth) - (chunkSize / 2) + roadWidth / 2 + offsetZ;

                    const blockGeo = new THREE.PlaneGeometry(blockSize, blockSize);
                    const blockMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    const block = new THREE.Mesh(blockGeo, blockMat);
                    block.rotation.x = -Math.PI / 2;
                    block.position.set(x, 0.1, z);
                    chunkGroup.add(block);

                    const buildingType = noise.noise2D(chunkX + i * 0.1, chunkZ + j * 0.1);
                    let height, width, depth, color;
                    const sizeNoise = noise.noise2D(chunkX + i * 0.2 + 300, chunkZ + j * 0.2 + 300);
                    if (sizeNoise < -0.5) { width = blockSize / 4; depth = blockSize / 4; }
                    else if (sizeNoise < 0) { width = blockSize / 2; depth = blockSize / 2; }
                    else if (sizeNoise < 0.5) { width = blockSize / 2; depth = blockSize; }
                    else { width = blockSize * 0.75; depth = blockSize * 0.75; }

                    if (buildingType < -0.3) {
                        height = 5 + Math.random() * 5;
                        color = 0x888888;
                    } else if (buildingType < 0.3) {
                        height = 10 + Math.random() * 10;
                        color = 0x666666;
                    } else {
                        height = 20 + Math.random() * 30;
                        color = 0x999999;
                    }

                    const buildingGeo = new THREE.BoxGeometry(width, height, depth);
                    const buildingMat = new THREE.MeshLambertMaterial({ color });
                    const building = new THREE.Mesh(buildingGeo, buildingMat);
                    building.position.set(x, height / 2, z);
                    chunkGroup.add(building);
                }
            }

            chunkGroup.position.set(chunkX * BASE_CHUNK_SIZE, 0, chunkZ * BASE_CHUNK_SIZE);
            chunkGroup.rotation.y = rotation;
            return chunkGroup;
        }

        function updateChunks() {
            const camChunkX = Math.floor(camera.position.x / BASE_CHUNK_SIZE);
            const camChunkZ = Math.floor(camera.position.z / BASE_CHUNK_SIZE);
            for (let x = camChunkX - VIEW_DISTANCE; x <= camChunkX + VIEW_DISTANCE; x++) {
                for (let z = camChunkZ - VIEW_DISTANCE; z <= camChunkZ + VIEW_DISTANCE; z++) {
                    const key = getChunkKey(x * BASE_CHUNK_SIZE, z * BASE_CHUNK_SIZE);
                    if (!chunks[key]) {
                        const chunk = generateChunk(x, z);
                        scene.add(chunk);
                        chunks[key] = chunk;
                    }
                }
            }
            for (const key in chunks) {
                const [x, z] = key.split(',').map(Number);
                if (Math.abs(x - camChunkX) > VIEW_DISTANCE + 1 || Math.abs(z - camChunkZ) > VIEW_DISTANCE + 1) {
                    scene.remove(chunks[key]);
                    delete chunks[key];
                }
            }
        }

        const moveSpeed = 0.5;
        const turnSpeed = 0.02;
        const keys = { w: false, a: false, s: false, d: false };
        document.addEventListener('keydown', (e) => { if (e.key in keys) keys[e.key] = true; });
        document.addEventListener('keyup', (e) => { if (e.key in keys) keys[e.key] = false; });

        function updateCamera() {
            if (keys.w) {
                camera.position.x -= Math.sin(camera.rotation.y) * moveSpeed;
                camera.position.z -= Math.cos(camera.rotation.y) * moveSpeed;
            }
            if (keys.s) {
                camera.position.x += Math.sin(camera.rotation.y) * moveSpeed;
                camera.position.z += Math.cos(camera.rotation.y) * moveSpeed;
            }
            if (keys.a) camera.rotation.y += turnSpeed;
            if (keys.d) camera.rotation.y -= turnSpeed;
            camera.position.y = 5;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateCamera();
            updateChunks();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>