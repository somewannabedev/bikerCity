<!DOCTYPE html>
<html>
<head>
    <title>Motorcycle City Ride</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
        }
    </style>
</head>
<body>
    <div id="info">Speed: 0.00 | Time: 0.00s</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        camera.position.set(20, 5, 100);
        camera.rotation.y = Math.PI;

        const BASE_CHUNK_SIZE = 64;
        const VIEW_DISTANCE = 3;
        const chunks = {};
        const noise = new SimplexNoise();
        const collisions = [];

        // Motorcycle variables
        let motorcycle = null;
        const maxLeanAngle = Math.PI / 6; // 30 degrees max lean

        // Load Motorcycle GLB Model
        const loader = new THREE.GLTFLoader();
        loader.load(
            'models/motorcycle.glb', // Adjust path to your GLB file
            function (gltf) {
                motorcycle = gltf.scene;
                motorcycle.scale.set(0.08, 0.08, 0.08); // Adjust scale as needed
                motorcycle.position.set(0, -7, -2); // In front of camera, above ground
                camera.add(motorcycle); // Attach to camera so it moves with it
                scene.add(camera); // Ensure camera is in scene
                console.log('Motorcycle loaded');
            },
            undefined,
            function (error) {
                console.error('Error loading motorcycle:', error);
            }
        );

        function getChunkKey(x, z) {
            return `${Math.floor(x / BASE_CHUNK_SIZE)},${Math.floor(z / BASE_CHUNK_SIZE)}`;
        }

        function generateChunk(chunkX, chunkZ) {
            const chunkGroup = new THREE.Group();
            const chunkSize = BASE_CHUNK_SIZE + noise.noise2D(chunkX * 0.05, chunkZ * 0.05) * 32;
            const blockSize = 12;
            const roadWidth = 4;
            const gridSize = Math.floor((chunkSize - roadWidth) / (blockSize + roadWidth));

            const offsetX = noise.noise2D(chunkX * 0.1, chunkZ * 0.1) * blockSize * 2;
            const offsetZ = noise.noise2D(chunkX * 0.1 + 100, chunkZ * 0.1 + 100) * blockSize * 2;
            const rotation = noise.noise2D(chunkX * 0.1 + 200, chunkZ * 0.1 + 200) * 0.3;

            const groundGeo = new THREE.PlaneGeometry(chunkSize, chunkSize);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            chunkGroup.add(ground);

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const blockX = i * (blockSize + roadWidth) - (chunkSize / 2) + roadWidth / 2 + offsetX;
                    const blockZ = j * (blockSize + roadWidth) - (chunkSize / 2) + roadWidth / 2 + offsetZ;

                    const blockGeo = new THREE.PlaneGeometry(blockSize, blockSize);
                    const blockMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    const block = new THREE.Mesh(blockGeo, blockMat);
                    block.rotation.x = -Math.PI / 2;
                    block.position.set(blockX, 0.1, blockZ);
                    chunkGroup.add(block);

                    let currentX = blockX - blockSize / 2;
                    const blockEndX = blockX + blockSize / 2;
                    const blockEndZ = blockZ + blockSize / 2;
                    let lastWidth = 0;

                    while (currentX < blockEndX) {
                        let currentZ = blockZ - blockSize / 2;
                        while (currentZ < blockEndZ) {
                            const buildingType = noise.noise2D(chunkX + currentX * 0.1, chunkZ + currentZ * 0.1);
                            let height, width, depth, color;
                            const sizeNoise = noise.noise2D(chunkX + currentX * 0.2 + 300, chunkZ + currentZ * 0.2 + 300);
                            if (sizeNoise < -0.5) { width = blockSize / 4; depth = blockSize / 4; }
                            else if (sizeNoise < 0) { width = blockSize / 2; depth = blockSize / 2; }
                            else if (sizeNoise < 0.5) { width = blockSize / 2; depth = blockSize; }
                            else { width = blockSize * 0.75; depth = blockSize * 0.75; }

                            if (buildingType < -0.3) {
                                height = 5 + Math.random() * 5;
                                color = 0x888888;
                            } else if (buildingType < 0.3) {
                                height = 10 + Math.random() * 10;
                                color = 0x666666;
                            } else {
                                height = 20 + Math.random() * 30;
                                color = 0x999999;
                            }

                            const gapChance = noise.noise2D(chunkX + currentX * 0.3 + 500, chunkZ + currentZ * 0.3 + 500);
                            if (gapChance > 0.9) {
                                width *= 0.9;
                                depth *= 0.9;
                            }

                            const buildingGeo = new THREE.BoxGeometry(width, height, depth);
                            const buildingMat = new THREE.MeshLambertMaterial({ color });
                            const building = new THREE.Mesh(buildingGeo, buildingMat);
                            const worldX = chunkX * BASE_CHUNK_SIZE + currentX + width / 2;
                            const worldZ = chunkZ * BASE_CHUNK_SIZE + currentZ + depth / 2;
                            building.position.set(currentX + width / 2, height / 2, currentZ + depth / 2);
                            chunkGroup.add(building);

                            collisions.push({
                                minX: worldX - width / 2,
                                maxX: worldX + width / 2,
                                minZ: worldZ - depth / 2,
                                maxZ: worldZ + depth / 2,
                                height: height
                            });

                            currentZ += depth;
                            if (currentZ + depth > blockEndZ) break;
                            lastWidth = width;
                        }
                        currentX += lastWidth || blockSize / 4;
                        if (currentX + (lastWidth || blockSize / 4) > blockEndX) break;
                    }
                }
            }

            chunkGroup.position.set(chunkX * BASE_CHUNK_SIZE, 0, chunkZ * BASE_CHUNK_SIZE);
            chunkGroup.rotation.y = rotation;
            return chunkGroup;
        }

        function updateChunks() {
            const camChunkX = Math.floor(camera.position.x / BASE_CHUNK_SIZE);
            const camChunkZ = Math.floor(camera.position.z / BASE_CHUNK_SIZE);
            for (let x = camChunkX - VIEW_DISTANCE; x <= camChunkX + VIEW_DISTANCE; x++) {
                for (let z = camChunkZ - VIEW_DISTANCE; z <= camChunkZ + VIEW_DISTANCE; z++) {
                    const key = getChunkKey(x * BASE_CHUNK_SIZE, z * BASE_CHUNK_SIZE);
                    if (!chunks[key]) {
                        const chunk = generateChunk(x, z);
                        scene.add(chunk);
                        chunks[key] = chunk;
                    }
                }
            }
            for (const key in chunks) {
                const [x, z] = key.split(',').map(Number);
                if (Math.abs(x - camChunkX) > VIEW_DISTANCE + 1 || Math.abs(z - camChunkZ) > VIEW_DISTANCE + 1) {
                    scene.remove(chunks[key]);
                    const chunkPosX = x * BASE_CHUNK_SIZE;
                    const chunkPosZ = z * BASE_CHUNK_SIZE;
                    for (let i = collisions.length - 1; i >= 0; i--) {
                        const col = collisions[i];
                        if (Math.abs(col.minX - chunkPosX) < BASE_CHUNK_SIZE && Math.abs(col.minZ - chunkPosZ) < BASE_CHUNK_SIZE) {
                            collisions.splice(i, 1);
                        }
                    }
                    delete chunks[key];
                }
            }
        }

        let baseSpeed = 0.5;
        let currentSpeed = baseSpeed;
        const minSpeed = 0.2;
        const turnSpeed = 0.02;
        const keys = { 'w': false, 'a': false, 's': false, 'd': false, 'W': false, 'S': false };
        let startTime = performance.now();
        let leanAngle = 0;

        document.addEventListener('keydown', (e) => {
            if (e.key in keys) keys[e.key] = true;
        });
        document.addEventListener('keyup', (e) => {
            if (e.key in keys) keys[e.key] = false;
        });

        function checkCollision(newX, newZ) {
            const cameraHeight = 5;
            const cameraRadius = 1;
            for (const col of collisions) {
                if (
                    newX + cameraRadius > col.minX && newX - cameraRadius < col.maxX &&
                    newZ + cameraRadius > col.minZ && newZ - cameraRadius < col.maxZ &&
                    cameraHeight < col.height
                ) {
                    return true;
                }
            }
            return false;
        }

        function updateCamera() {
            if (keys['w'] || keys['W']) currentSpeed = Math.min(currentSpeed + 0.1, baseSpeed * 2);
            if (keys['s'] || keys['S']) {
                currentSpeed = Math.max(currentSpeed - 0.1, minSpeed);
            } else if (!(keys['w'] || keys['W'])) {
                currentSpeed += (baseSpeed - currentSpeed) * 0.05;
            }

            let turnAmount = 0;
            if (keys['a']) turnAmount += turnSpeed;
            if (keys['d']) turnAmount -= turnSpeed;
            camera.rotation.y += turnAmount;

            // Calculate lean based on turn
            const leanTarget = +turnAmount * 200; // Proportional to turn speed
            leanAngle += (leanTarget - leanAngle) * 0.003; // Smooth transition
            leanAngle = Math.max(-maxLeanAngle, Math.min(maxLeanAngle, leanAngle));
            camera.rotation.z = leanAngle;

            // Apply lean to motorcycle if loaded
            if (motorcycle) {
                motorcycle.rotation.z = leanAngle;
            }

            const newX = camera.position.x - Math.sin(camera.rotation.y) * currentSpeed;
            const newZ = camera.position.z - Math.cos(camera.rotation.y) * currentSpeed;

            if (!checkCollision(newX, newZ)) {
                camera.position.x = newX;
                camera.position.z = newZ;
            }

            camera.position.y = 5;
        }

        function updateDisplay() {
            const elapsedTime = (performance.now() - startTime) / 1000;
            document.getElementById('info').innerText = 
                `Speed: ${currentSpeed.toFixed(2)} | Time: ${elapsedTime.toFixed(2)}s`;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateCamera();
            updateChunks();
            updateDisplay();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>